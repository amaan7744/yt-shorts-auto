name: Auto YouTube Short

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0,2,5,7,10,12,14,17,19,21 * * *"

jobs:
  make-video:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: write

    steps:
      # ----------------------------------------------------------
      # CHECKOUT + PYTHON
      # ----------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install system deps
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq libsndfile1
          pip install --upgrade pip
          pip install -r requirements.txt

      # ----------------------------------------------------------
      # PICK CATEGORY
      # ----------------------------------------------------------
      - name: Pick category
        run: |
          CATEGORY=$(shuf -e horror crime mystery | head -n1)
          echo "CATEGORY=$CATEGORY" >> "$GITHUB_ENV"
          echo "Picked category: $CATEGORY"

      # ----------------------------------------------------------
      # FETCH WIKIPEDIA TEXT
      # ----------------------------------------------------------
      - name: Fetch Wikipedia source
        run: |
          if [ "${CATEGORY}" = "horror" ]; then
            TOPIC="List_of_reportedly_haunted_locations_in_the_United_States"
          elif [ "${CATEGORY}" = "crime" ]; then
            TOPIC="List_of_unsolved_murder_cases_in_the_United_States"
          else
            TOPIC="List_of_missing_persons_cases"
          fi

          echo "Using Wikipedia topic: $TOPIC"

          TEXT=$(curl -s "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=1&titles=${TOPIC}&format=json" \
            | jq -r '.query.pages[]?.extract' | head -c 8000)

          if [ -z "$TEXT" ]; then
            echo "Error: Wikipedia returned empty text."
            exit 1
          fi

          {
            echo "source_text<<EOF"
            echo "$TEXT"
            echo "EOF"
          } >> "$GITHUB_ENV"

      # ----------------------------------------------------------
      # GROQ SCRIPT (HOOK + CLIFFHANGER, NO REPEAT TOPICS)
      # ----------------------------------------------------------
      - name: Generate script with Groq
        env:
          GROQ_KEY: ${{ secrets.GROQ_KEY }}
          SOURCE_TEXT: ${{ env.source_text }}
        run: |
          python << 'PY'
          import os, re, json, time, pathlib, requests, random, sys

          api_key = os.environ.get("GROQ_KEY")
          if not api_key:
              print("GROQ_KEY missing.")
              sys.exit(1)

          raw_text = os.environ.get("SOURCE_TEXT", "")
          category = os.environ.get("CATEGORY", "mystery")

          # Track used titles to avoid repeats
          used_path = pathlib.Path("used_topics.txt")
          used_titles = []
          if used_path.exists():
              used_titles = [
                  line.strip()
                  for line in used_path.read_text(encoding="utf-8").splitlines()
                  if line.strip()
              ]

          avoid_clause = "; ".join(used_titles[-40:]) if used_titles else ""

          url = "https://api.groq.com/openai/v1/chat/completions"
          headers = {
              "Authorization": f"Bearer {api_key}",
              "Content-Type": "application/json",
          }

          # SYSTEM PROMPT: retention-obsessed crime storytelling
          system_content = (
              "You ONLY return valid JSON. Keys: title, description, tags, script, visual_keywords. "
              "Write a 30–38 second YouTube Short true-crime / mystery story (≈110–140 words). "
              "Think like a top 1% Shorts storyteller obsessed with retention (MrBeast pacing) "
              "but in a dark, serious true-crime tone (no jokes, no cringe). "
              "SCRIPT RULES: "
              "1) Line 1 must be a violent or shocking hook, directly addressing the viewer, ≤ 11 words. "
              "2) Use short lines separated by \\n, each ≤ 14 words. "
              "3) First 3–4 lines open strong loops: hint at the crime, hide key details. "
              "4) Middle reveals concrete, visual details (who, where, how) that escalate tension. "
              "5) Last 2–3 lines end with a punchy, open-ended question or chilling doubt. "
              "   Never give a neat solution or happy ending. "
              "6) No YouTube meta (no 'in this video', 'subscribe', 'Shorts'). "
              "7) No references to Wikipedia, articles, 'according to records', etc. "
              "8) Tone: calm, cinematic, American English documentary narrator. "
              "visual_keywords: 3–6 short phrases for cinematic B-roll, like "
              "'police lights on wet asphalt', 'lonely street at 3am', 'grainy CCTV hallway', "
              "'crime scene tape', 'shadowy figure under streetlamp'."
          )

          # USER PROMPT: one case only, no repeats
          user_content = (
              "From the raw text below, choose ONE specific case (person, location, or incident) "
              f"in the category '{category}'. Turn it into a highly watchable 30–38 second YouTube Short "
              "with a killer hook, rising tension, and a final cliffhanger question. "
              "Do NOT repeat any previously used titles or case topics. "
          )
          if avoid_clause:
              user_content += "Avoid repeating these topics or titles: " + avoid_clause + ". "
          user_content += (
              "Return ONLY JSON with keys: title, description, tags, script, visual_keywords. "
              "Use \\n for line breaks in 'script'. "
              "RAW TEXT: " + raw_text[:2000].replace("\n", " ")
          )

          payload = {
              "model": "llama-3.1-8b-instant",
              "temperature": 0.8,
              "max_tokens": 900,
              "messages": [
                  {"role": "system", "content": system_content},
                  {"role": "user", "content": user_content},
              ],
          }

          def try_parse(text: str):
              text = text.strip()
              if text.startswith("```"):
                  text = re.sub(r"^```[a-zA-Z0-9]*", "", text)
                  text = text.replace("```", "")
              start = text.find("{")
              end = text.rfind("}")
              if start == -1 or end == -1 or end <= start:
                  raise ValueError("No JSON object found")
              candidate = text[start:end+1]
              candidate = re.sub(r",(\s*[}\]])", r"\1", candidate)
              return json.loads(candidate)

          def good_length(script: str) -> bool:
              wc = len(script.replace("\\n", " ").split())
              return 110 <= wc <= 140

          data = None
          for attempt in range(1, 4):
              print(f"=== Groq attempt {attempt}/3 ===")
              try:
                  resp = requests.post(url, headers=headers, json=payload, timeout=90)
                  j = resp.json()
                  content = j["choices"][0]["message"]["content"]
              except Exception as e:
                  print("Groq error:", e, file=sys.stderr)
                  time.sleep(4)
                  continue

              try:
                  data = try_parse(content)
              except Exception as e:
                  print("JSON parse error:", e, file=sys.stderr)
                  time.sleep(3)
                  data = None
                  continue

              title = (data.get("title") or "").strip()
              script = (data.get("script") or "").strip()
              vkeys = data.get("visual_keywords")

              if not title or not script or not isinstance(vkeys, list) or not vkeys:
                  print("Missing required fields, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              if title in used_titles:
                  print("Title already used, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              if not good_length(script):
                  print("Bad length (needs 110–140 words), retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              first_line = script.split("\\n", 1)[0].strip()
              if len(first_line.split()) > 14:
                  print("Hook too long, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              break

          if data is None:
              print("Groq failed after 3 attempts, using fallback.", file=sys.stderr)
              fallback_script = (
                  "This isn’t a movie – this actually happened.\\n"
                  "A quiet house on a normal night.\\n"
                  "Then one scream… and a door that locked itself.\\n"
                  "No fingerprints. No weapon. No clear suspect.\\n"
                  "Neighbors saw shadows in the window – but nobody leaving.\\n"
                  "Police swear the house was sealed from the inside.\\n"
                  "So who walked in… and how did they ever get out?"
              )
              data = {
                  "title": f"Locked Room {category.title()} Mystery",
                  "description": "A disturbing unsolved case in a sealed house.",
                  "tags": [category, "true crime", "mystery", "shorts"],
                  "script": fallback_script,
                  "visual_keywords": [
                      "dimly lit hallway",
                      "police lights outside house",
                      "door with crime scene tape",
                      "empty living room at night",
                  ],
              }

          script_for_file = data["script"].replace("\\n", "\n")
          pathlib.Path("script.txt").write_text(script_for_file, encoding="utf-8")
          pathlib.Path("groq_raw.json").write_text(
              json.dumps(data, ensure_ascii=False, indent=2),
              encoding="utf-8",
          )

          title = data.get("title", "Untitled Mystery")
          visual_keywords = data.get("visual_keywords", [])
          description = data.get("description", "")
          tags = data.get("tags", [])

          safe_title = re.sub(r"[^A-Za-z0-9 _-]", "", title)[:60].strip() or "Mystery Short"

          env_path = os.environ["GITHUB_ENV"]
          with open(env_path, "a", encoding="utf-8") as f:
              f.write(f"TITLE={title}\n")
              f.write(f"DESCRIPTION={description}\n")
              f.write(f"TAGS={','.join(tags)}\n")
              f.write(f"SANITIZED_TITLE={safe_title}\n")
              f.write(f"VISUAL_KEYWORDS={','.join(visual_keywords)}\n")

          print("Final title:", title)
          print("First lines of script:")
          for i, line in enumerate(script_for_file.splitlines()[:4], 1):
              print(i, ":", line)
          PY

      # ----------------------------------------------------------
      # TTS: TACOTRON2 SINGLE PASS (ONE VOICE, NO CHUNKS)
      # ----------------------------------------------------------
      - name: Generate Voice (Tacotron2 single pass)
        env:
          COQUI_TOS_AGREED: "1"
        run: |
          python << 'EOF'
          import os, sys
          from TTS.api import TTS

          SCRIPT_PATH = "script.txt"
          AUDIO_PATH = "tts-audio.wav"

          if not os.path.exists(SCRIPT_PATH):
              print("script.txt not found")
              sys.exit(1)

          script = open(SCRIPT_PATH, "r", encoding="utf-8").read().strip()
          if not script:
              print("script.txt empty")
              sys.exit(1)

          print("Loading Tacotron2 model (single voice)...")
          MODEL_NAME = "tts_models/en/ljspeech/tacotron2-DDC"
          tts = TTS(MODEL_NAME)

          # ONE SHOT: no chunks, no multiple voices, one continuous narration
          print("Generating full audio in a single pass...")
          tts.tts_to_file(
              text=script,
              file_path=AUDIO_PATH,
          )

          if not os.path.exists(AUDIO_PATH) or os.path.getsize(AUDIO_PATH) == 0:
              print("tts-audio.wav not created correctly")
              sys.exit(1)

          print("Tacotron2 single-pass TTS complete:", AUDIO_PATH)
          EOF

      # ----------------------------------------------------------
      # FETCH PEXELS CRIME B-ROLL (TRIMMED TO 5s)
      # ----------------------------------------------------------
      - name: Fetch Pexels crime B-roll (trimmed)
        env:
          PEXELS_KEY: ${{ secrets.PEXELS_KEY }}
          KEYWORDS: ${{ env.VISUAL_KEYWORDS }}
        run: |
          python << 'EOF'
          import os, sys, json, time, pathlib, random, urllib.parse
          import requests
          from pydub import AudioSegment

          PEXELS_KEY = os.environ.get("PEXELS_KEY")
          raw_keywords = os.environ.get("KEYWORDS", "")

          prepared_dir = pathlib.Path("prepared")
          prepared_dir.mkdir(exist_ok=True)

          def fallback_black():
              out = prepared_dir / "black_placeholder.mp4"
              if not out.exists():
                  os.system(
                      f"ffmpeg -y -f lavfi -i color=c=black:s=1080x1920:r=30:d=40 "
                      f"-c:v libx264 -preset veryfast -crf 23 \"{out}\""
                  )
              print("Using black placeholder clip.")
              return [out]

          if not PEXELS_KEY:
              print("PEXELS_KEY missing, falling back to black video.")
              clips = fallback_black()
          else:
              kws = [k.strip() for k in raw_keywords.split(",") if k.strip()]
              if not kws:
                  kws = [
                      "crime scene night",
                      "dark alley crime",
                      "police lights crime",
                      "cctv night hallway",
                      "mysterious silhouette street",
                  ]
              else:
                  kws = kws + [
                      "crime scene tape at night",
                      "police flashing lights in alley",
                      "cctv footage dark hallway",
                      "lonely city street 3am"
                  ]

              try:
                  audio = AudioSegment.from_wav("tts-audio.wav")
                  dur = audio.duration_seconds
              except Exception as e:
                  print("Could not read tts-audio.wav, defaulting duration:", e)
                  dur = 35.0

              min_clips = 4
              max_clips = 8
              ideal = int(round(dur / 5.0))
              n_clips = max(min_clips, min(max_clips, ideal))

              print(f"Audio duration ~{dur:.1f}s, planning {n_clips} B-roll clips.")
              print("Search keywords:", kws)

              random.shuffle(kws)

              downloaded = []
              kw_idx = 0

              while len(downloaded) < n_clips and kw_idx < len(kws):
                  query = kws[kw_idx]
                  kw_idx += 1
                  q = urllib.parse.quote_plus(query)
                  print(f"Searching Pexels for: {query}")

                  try:
                      resp = requests.get(
                          f"https://api.pexels.com/videos/search?query={q}&orientation=portrait&per_page=4",
                          headers={"Authorization": PEXELS_KEY},
                          timeout=30,
                      )
                  except Exception as e:
                      print("Request error:", e)
                      continue

                  if resp.status_code != 200:
                      print("Pexels status:", resp.status_code)
                      continue

                  try:
                      videos = resp.json().get("videos", [])
                  except Exception as e:
                      print("JSON parse error:", e)
                      continue

                  if not videos:
                      print("No videos for", query)
                      continue

                  random.shuffle(videos)
                  for vid in videos:
                      files = vid.get("video_files", [])
                      files.sort(
                          key=lambda x: int(x.get("width", 0)) * int(x.get("height", 0)),
                          reverse=True,
                      )
                      if not files:
                          continue

                      url = files[0].get("link")
                      if not url:
                          continue

                      idx = len(downloaded) + 1
                      raw_path = prepared_dir / f"raw_{idx}.mp4"
                      out_path = prepared_dir / f"clip_{idx}.mp4"

                      print(f"Downloading clip {idx}: {url}")
                      ok = False
                      for attempt in range(3):
                          try:
                              r = requests.get(url, stream=True, timeout=60)
                              r.raise_for_status()
                              with open(raw_path, "wb") as f:
                                  for chunk in r.iter_content(chunk_size=8192):
                                      f.write(chunk)
                              ok = True
                              break
                          except Exception as e:
                              print(f"Download error (attempt {attempt+1}): {e}")
                              time.sleep(2)

                      if not ok:
                          print("Skipping this video after failed downloads.")
                          continue

                      cmd = (
                          f"ffmpeg -y -i \"{raw_path}\" "
                          f"-t 5 -an "
                          f"-vf scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920 "
                          f"-c:v libx264 -preset veryfast -crf 25 "
                          f"\"{out_path}\""
                      )
                      print("Trimming & scaling:", cmd)
                      os.system(cmd)

                      try:
                          raw_path.unlink()
                      except Exception:
                          pass

                      if out_path.exists() and out_path.stat().st_size > 0:
                          downloaded.append(out_path)
                          print("Added trimmed clip:", out_path)
                          if len(downloaded) >= n_clips:
                              break

              if not downloaded:
                  print("No Pexels clips downloaded, falling back to black video.")
                  downloaded = fallback_black()

              clips = downloaded

          print("Prepared clips:")
          for c in clips:
              print(" -", c)
          EOF

      # ----------------------------------------------------------
      # BUILD CLIP LIST FOR CONCAT
      # ----------------------------------------------------------
      - name: Build clip list
        run: |
          python << 'EOF'
          import os, random, pathlib, math
          from pydub import AudioSegment

          audio = AudioSegment.from_wav("tts-audio.wav")
          dur = audio.duration_seconds

          clips = [str(p) for p in pathlib.Path("prepared").glob("*.mp4")]
          if not clips:
              raise SystemExit("No prepared clips found")

          random.shuffle(clips)

          ideal_count = max(3, min(len(clips), math.ceil(dur / 5.0)))
          selected = clips[:ideal_count]

          with open("clip_list.txt","w") as f:
              for c in selected:
             
