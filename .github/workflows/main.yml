name: Auto YouTube Short

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0,2,5,7,10,12,14,17,19,21 * * *"

concurrency:
  group: auto-youtube-short
  cancel-in-progress: true

jobs:
  make-video:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      contents: write

    steps:
      # ----------------------------------------------------------
      # CHECKOUT + PYTHON + CACHE
      # ----------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install system deps
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq libsndfile1
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt

      - name: Preflight check
        run: |
          set -euo pipefail
          if [ ! -f requirements.txt ]; then
            echo "requirements.txt missing"; exit 1;
          fi
          python -c "import json" >/dev/null 2>&1 || { echo 'Python sanity failed'; exit 1; }

      # ----------------------------------------------------------
      # PICK CATEGORY
      # ----------------------------------------------------------
      - name: Pick category
        run: |
          set -euo pipefail
          CATEGORY=$(shuf -e horror crime mystery | head -n1)
          echo "CATEGORY=$CATEGORY" >> "$GITHUB_ENV"
          echo "Picked category: $CATEGORY"

      # ----------------------------------------------------------
      # FETCH WIKIPEDIA TEXT
      # ----------------------------------------------------------
      - name: Fetch Wikipedia source
        run: |
          set -euo pipefail
          if [ "${CATEGORY}" = "horror" ]; then
            TOPIC="List_of_reportedly_haunted_locations_in_the_United_States"
          elif [ "${CATEGORY}" = "crime" ]; then
            TOPIC="List_of_unsolved_murder_cases_in_the_United_States"
          else
            TOPIC="List_of_missing_persons_cases"
          fi

          echo "Using Wikipedia topic: $TOPIC"

          TEXT=$(curl -s "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=1&titles=${TOPIC}&format=json" \
            | jq -r '.query.pages[]?.extract' | head -c 8000)

          if [ -z "$TEXT" ]; then
            echo "Error: Wikipedia returned empty text."
            exit 1
          fi

          {
            echo "source_text<<EOF"
            echo "$TEXT"
            echo "EOF"
          } >> "$GITHUB_ENV"

      # ----------------------------------------------------------
      # GROQ SCRIPT (NEUTRAL INVESTIGATIVE TRUE-CRIME)
      # ----------------------------------------------------------
      - name: Generate script with Groq
        env:
          GROQ_KEY: ${{ secrets.GROQ_KEY }}
          SOURCE_TEXT: ${{ env.source_text }}
        run: |
          python << 'PY'
          import os, re, json, time, pathlib, requests, random, sys, string

          api_key = os.environ.get("GROQ_KEY")
          if not api_key:
              print("GROQ_KEY missing.")
              sys.exit(1)

          raw_text = os.environ.get("SOURCE_TEXT", "")
          category = os.environ.get("CATEGORY", "mystery")

          used_path = pathlib.Path("used_topics.txt")
          used_titles = []
          if used_path.exists():
              used_titles = [
                  line.strip()
                  for line in used_path.read_text(encoding="utf-8").splitlines()
                  if line.strip()
              ]

          avoid_clause = "; ".join(used_titles[-80:]) if used_titles else ""

          url = "https://api.groq.com/openai/v1/chat/completions"
          headers = {
              "Authorization": f"Bearer {api_key}",
              "Content-Type": "application/json",
          }

          # ---------- SCRIPT STYLE ----------
          system_content = (
              "You ONLY return valid JSON. Keys: title, description, tags, script, visual_keywords. "
              "Write a 30–40 second true-crime short script (≈95–130 words) with a neutral, "
              "investigative tone. The narration should feel like a calm investigator summarizing "
              "a real case for a professional true-crime documentary.\n\n"
              "Follow these rules:\n"
              "1) Begin with a simple, quiet moment that leads into a real-world crime or "
              "disappearance (night road, empty street, routine activity, etc.).\n"
              "2) Present the crime or disappearance using straightforward, factual-style narration.\n"
              "3) Describe only minimal, realistic clues such as tire marks, phone records, "
              "surveillance gaps, or witness absence.\n"
              "4) Avoid drama, sensationalism, emotional language, or exaggerated suspense.\n"
              "5) Maintain a steady pace similar to a professional true-crime documentary voiceover.\n"
              "6) Conclude with a direct, concise question OR a single unresolved detail that "
              "clearly highlights the mystery.\n"
              "7) Keep everything suitable for a 30–40 second YouTube Short.\n"
              "8) Use short lines separated by \\n, each ≤ 16 words.\n"
              "9) Keep content PG-13: no graphic gore, no slurs, no shock-language.\n"
              "10) visual_keywords: 3–6 short phrases for grounded, dark B-roll like "
              "'car on empty road at night', 'streetlights over wet asphalt', "
              "'small town intersection at night', 'silent police station hallway'.\n"
          )

          user_content = (
              "From the raw text below, pick ONE real case clearly identified in the text: "
              "a specific victim and their disappearance or killing. Base the story ONLY "
              "on that real case.\n\n"
              "Requirements:\n"
              "- Use the victim's full name at least once.\n"
              "- Mention the location (city/state/country) at least once.\n"
              "- You may mention the year, but not in the first line.\n"
              "- Keep the tone neutral, like a case summary in a documentary.\n"
              "- Do NOT dramatize or sensationalize. No phrases like 'horrifying', 'chilling', "
              "'nightmare', 'terrifying', 'unbelievable', etc.\n"
              "- Do NOT copy or reuse any previous examples or phrasings. Generate a completely new "
              "script each time.\n"
              "- Do NOT reference Wikipedia, articles, journalists, or 'reports'. Just state the case.\n"
              f"The general category is '{category}'. "
          )
          if avoid_clause:
              user_content += "Avoid repeating these topics or titles: " + avoid_clause + ".\n"
          user_content += (
              "Return ONLY JSON with keys: title, description, tags, script, visual_keywords. "
              "Use \\n for line breaks in 'script'. "
              "RAW TEXT: " + raw_text[:2000].replace("\n", " ")
          )

          payload = {
              "model": "llama-3.1-8b-instant",
              "temperature": 0.6,
              "max_tokens": 900,
              "messages": [
                  {"role": "system", "content": system_content},
                  {"role": "user", "content": user_content},
              ],
          }

          def try_parse(text: str):
              text = text.strip()
              if text.startswith("```"):
                  text = re.sub(r"^```[a-zA-Z0-9]*", "", text)
                  text = text.replace("```", "")
              start = text.find("{")
              end = text.rfind("}")
              if start == -1 or end == -1 or end <= start:
                  raise ValueError("No JSON object found")
              candidate = text[start:end+1]
              candidate = re.sub(r",(\s*[}\]])", r"\1", candidate)
              return json.loads(candidate)

          def good_length(script: str) -> bool:
              wc = len(script.replace("\\n", " ").split())
              return 95 <= wc <= 130

          ALLOWED_CHARS = set(string.ascii_letters + string.digits + " ,.'\"?!-:\n")

          def clean_script(s: str) -> str:
              s = s.replace("\r", "")
              s = "".join(ch for ch in s if ch in ALLOWED_CHARS)
              s = re.sub(r"[ \t]+", " ", s)
              s = re.sub(r"[!?]{3,}", "!!", s)
              s = re.sub(r"\.{4,}", "...", s)
              lines = [ln.strip() for ln in s.split("\n")]
              lines = [ln for ln in lines if ln]
              return "\n".join(lines)

          def count_question_lines(script: str) -> int:
              return sum(1 for line in script.split("\n") if line.strip().endswith("?"))

          data = None
          for attempt in range(1, 4):
              print(f"=== Groq attempt {attempt}/3 ===")
              try:
                  resp = requests.post(url, headers=headers, json=payload, timeout=90)
                  resp.raise_for_status()
                  j = resp.json()
                  content = j["choices"][0]["message"]["content"]
              except Exception as e:
                  print("Groq error:", e, file=sys.stderr)
                  time.sleep(4)
                  continue

              try:
                  data = try_parse(content)
              except Exception as e:
                  print("JSON parse error:", e, file=sys.stderr)
                  time.sleep(3)
                  data = None
                  continue

              title = (data.get("title") or "").strip()
              script = (data.get("script") or "").strip()
              vkeys = data.get("visual_keywords")

              if not title or not script or not isinstance(vkeys, list) or not vkeys:
                  print("Missing required fields, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              if title in used_titles:
                  print("Title already used, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              script = clean_script(script)

              if not good_length(script):
                  print("Bad length (needs ~95–130 words), retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              lines = [l.strip() for l in script.split("\n") if l.strip()]
              if not lines:
                  print("Empty lines after cleaning, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              last = lines[-1]
              if not last.endswith("?") and "unknown" not in last.lower() and "never" not in last.lower():
                  print("Last line not clearly highlighting the mystery, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              if count_question_lines(script) > 2:
                  print("Too many question lines, retrying...", file=sys.stderr)
                  data = None
                  time.sleep(3)
                  continue

              data["script"] = script
              break

          if data is None:
              print("Groq failed after 3 attempts, using fallback.", file=sys.stderr)
              fallback_script = (
                  "It starts with a routine drive home on a quiet county road.\n"
                  "A car is later found abandoned on the shoulder, hazard lights still on.\n"
                  "Inside: a wallet, phone, and keys. No sign of a struggle.\n"
                  "Tire marks show one sudden stop, then nothing leaving the scene.\n"
                  "Nearby cameras record the car passing once, but never coming back.\n"
                  "No confirmed witnesses. No confirmed sightings.\n"
                  "To this day, investigators still don’t know where the driver went."
              )
              data = {
                  "title": f"Unfinished Drive {category.title()} Case",
                  "description": "A neutral, factual look at a driver who vanished on a routine trip.",
                  "tags": [category, "true crime", "mystery", "shorts"],
                  "script": fallback_script,
                  "visual_keywords": [
                      "car on empty road at night",
                      "hazard lights blinking on roadside",
                      "empty driver's seat",
                      "quiet police station hallway",
                  ],
              }

          script_for_file = data["script"]
          pathlib.Path("script.txt").write_text(script_for_file, encoding="utf-8")
          pathlib.Path("groq_raw.json").write_text(
              json.dumps(data, ensure_ascii=False, indent=2),
              encoding="utf-8",
          )

          title = data.get("title", "Untitled Mystery").strip()
          visual_keywords = data.get("visual_keywords", [])
          description = data.get("description", "").strip()
          tags = data.get("tags", [])

          safe_title = re.sub(r"[^A-Za-z0-9 _-]", "", title)[:60].strip() or "Mystery Short"

          env_path = os.environ["GITHUB_ENV"]
          with open(env_path, "a", encoding="utf-8") as f:
              f.write(f"TITLE={title}\n")
              f.write(f"DESCRIPTION={description}\n")
              f.write(f"TAGS={','.join(tags)}\n")
              f.write(f"SANITIZED_TITLE={safe_title}\n")
              f.write(f"VISUAL_KEYWORDS={','.join(visual_keywords)}\n")

          wc = len(script_for_file.replace("\n", " ").split())
          print("Final title:", title)
          print(f"Script word count: {wc}")
          print("First lines of script:")
          for i, line in enumerate(script_for_file.splitlines()[:4], 1):
              print(i, ":", line)
          PY

      # ----------------------------------------------------------
      # TTS VIA tts_generate.py (XTTS CLONE)
      # ----------------------------------------------------------
      - name: Generate Voice (via tts_generate.py)
        env:
          COQUI_TOS_AGREED: "1"
          TTS_SCRIPT_PATH: "script.txt"
          TTS_OUTPUT_PATH: "tts-audio.wav"
          TTS_USE_CLONE: "1"
          TTS_VOICE_PATH: "voices/aman.wav"
          TTS_LANGUAGE: "en"
          TTS_SPEED: "0.96"
          TTS_PRIMARY_MODEL: "tts_models/en/vctk/vits"
          TTS_PRIMARY_SPEAKER: "p227"
        run: |
          set -euo pipefail
          python tts_generate.py

      # ----------------------------------------------------------
      # ADD NATURAL AMBIENCE (RAIN / NIGHT / WIND)
      # ----------------------------------------------------------
      - name: Add natural ambience under narration
        run: |
          python << 'PY'
          import os
          import random
          from pydub import AudioSegment

          BASE = "tts-audio.wav"
          if not os.path.exists(BASE) or os.path.getsize(BASE) == 0:
              print("No base TTS audio found; skipping ambience.")
              raise SystemExit(0)

          keywords = ("rain", "night", "street", "wind", "thunder", "storm", "city", "ambience", "ambient")

          candidates = []
          for root, dirs, files in os.walk("."):
              if any(part.startswith(".git") for part in root.split(os.sep)):
                  continue
              for f in files:
                  lower = f.lower()
                  if not lower.endswith((".wav", ".mp3", ".flac", ".ogg")):
                      continue
                  if any(k in lower for k in keywords):
                      candidates.append(os.path.join(root, f))

          if not candidates:
              print("No ambience audio found containing rain/night/wind/etc. Keeping clean voice.")
              raise SystemExit(0)

          bg_path = random.choice(candidates)
          print("Using ambience file:", bg_path)

          voice = AudioSegment.from_file(BASE)
          bg = AudioSegment.from_file(bg_path)

          if len(bg) < len(voice):
              loops = len(voice) // len(bg) + 1
              bg = (bg * loops)[:len(voice)]
          else:
              bg = bg[:len(voice)]

          bg = bg - 18  # push ambience back

          mixed = voice.overlay(bg)
          mixed.export(BASE, format="wav")
          print("Ambience mixed into tts-audio.wav")
          PY

      # ----------------------------------------------------------
      # FETCH PEXELS DARK B-ROLL (MANUAL LINKS FIRST)
      # ----------------------------------------------------------
      - name: Fetch Pexels dark B-roll (trimmed)
        env:
          PEXELS_KEY: ${{ secrets.PEXELS_KEY }}
          KEYWORDS: ${{ env.VISUAL_KEYWORDS }}
        run: |
          python << 'PY'
          import os, sys, json, time, pathlib, random, urllib.parse, math
          import requests
          from pydub import AudioSegment

          PEXELS_KEY = os.environ.get("PEXELS_KEY")
          raw_keywords = os.environ.get("KEYWORDS", "")

          prepared_dir = pathlib.Path("prepared")
          prepared_dir.mkdir(exist_ok=True)

          def fallback_black(duration_sec: float = 40.0):
              out = prepared_dir / "black_placeholder.mp4"
              d = max(20.0, duration_sec + 3.0)
              cmd = (
                  f"ffmpeg -y -f lavfi -i color=c=black:s=1080x1920:r=30:d={d} "
                  f"-c:v libx264 -preset veryfast -crf 23 \"{out}\""
              )
              os.system(cmd)
              print("Using black placeholder clip.")
              return [out]

          try:
              audio = AudioSegment.from_wav("tts-audio.wav")
              dur = audio.duration_seconds
          except Exception as e:
              print("Could not read tts-audio.wav, defaulting duration:", e)
              dur = 35.0

          downloaded = []

          # --------- MANUAL LINKS (YOUR CURATED PEXELS VIDEOS) ----------
          manual_file = pathlib.Path("pexels_links.txt")
          manual_links = []
          if manual_file.exists():
              for line in manual_file.read_text(encoding="utf-8").splitlines():
                  line = line.strip()
                  if line and not line.startswith("#"):
                      manual_links.append(line)

          if manual_links:
              print("Using manual Pexels links from pexels_links.txt")
              for idx, url in enumerate(manual_links, start=1):
                  raw_path = prepared_dir / f"manual_raw_{idx}.mp4"
                  out_path = prepared_dir / f"clip_{idx}.mp4"
                  print(f"Downloading manual clip {idx}: {url}")
                  ok = False
                  for attempt in range(3):
                      try:
                          r = requests.get(url, stream=True, timeout=80)
                          r.raise_for_status()
                          with open(raw_path, "wb") as f:
                              for chunk in r.iter_content(chunk_size=8192):
                                  f.write(chunk)
                          ok = True
                          break
                      except Exception as e:
                          print(f"Manual download error (attempt {attempt+1}): {e}")
                          time.sleep(2)
                  if not ok:
                      print("Skipping this manual video after failed downloads.")
                      continue

                  cmd = (
                      f"ffmpeg -y -i \"{raw_path}\" "
                      f"-t 5 -an "
                      f"-vf scale=1080:1920:force_original_aspect_ratio=increase,"
                      f"crop=1080:1920 "
                      f"-c:v libx264 -preset veryfast -crf 25 "
                      f"\"{out_path}\""
                  )
                  print("Trimming & scaling (manual):", cmd)
                  os.system(cmd)

                  try:
                      raw_path.unlink()
                  except Exception:
                      pass

                  if out_path.exists() and out_path.stat().st_size > 0:
                      downloaded.append(out_path)
                      print("Added manual trimmed clip:", out_path)

          # If manual links gave us clips, we skip API.
          clips = []
          if downloaded:
              clips = downloaded
          else:
              print("No usable manual clips, falling back to Pexels API / black video.")
              # --------- PEXELS API FALLBACK ----------
              if not PEXELS_KEY:
                  print("PEXELS_KEY missing, falling back to black video.")
                  clips = fallback_black(dur)
              else:
                  base_kws = [k.strip() for k in raw_keywords.split(",") if k.strip()]
                  if not base_kws:
                      base_kws = [
                          "person walking alone at night",
                          "dark empty street at night",
                          "police lights in dark alley",
                          "lonely city street 3am",
                          "shadowy figure under streetlamp",
                      ]
                  kws = []
                  for k in base_kws:
                      kws.append(k + " night street")
                  kws.extend([
                      "dark alley crime scene",
                      "empty road at night with police lights",
                      "street at 3am with one person",
                  ])

                  min_clips = 4
                  max_clips = 8
                  ideal = int(round(dur / 5.0))
                  n_clips = max(min_clips, min(max_clips, ideal))

                  print(f"Audio duration ~{dur:.1f}s, planning {n_clips} B-roll clips.")
                  print("Search keywords (dark themed):", kws)

                  random.shuffle(kws)

                  while len(downloaded) < n_clips and kws:
                      query = kws.pop()
                      q = urllib.parse.quote_plus(query)
                      print(f"Searching Pexels for: {query}")

                      try:
                          resp = requests.get(
                              f"https://api.pexels.com/videos/search?query={q}&orientation=portrait&per_page=5",
                              headers={"Authorization": PEXELS_KEY},
                              timeout=40,
                          )
                      except Exception as e:
                          print("Request error:", e)
                          continue

                      if resp.status_code == 429:
                          print("Pexels rate limited us (429). Using fallback black video.")
                          downloaded = fallback_black(dur)
                          break

                      if resp.status_code >= 500:
                          print("Pexels server error:", resp.status_code)
                          time.sleep(5)
                          continue

                      if resp.status_code != 200:
                          print("Pexels status:", resp.status_code)
                          continue

                      try:
                          videos = resp.json().get("videos", [])
                      except Exception as e:
                          print("JSON parse error:", e)
                          continue

                      if not videos:
                          print("No videos for", query)
                          continue

                      random.shuffle(videos)
                      for vid in videos:
                          files = vid.get("video_files", [])
                          files.sort(
                              key=lambda x: int(x.get("width", 0)) * int(x.get("height", 0)),
                              reverse=True,
                          )
                          if not files:
                              continue

                          url = files[0].get("link")
                          if not url:
                              continue

                          idx = len(downloaded) + 1
                          raw_path = prepared_dir / f"raw_{idx}.mp4"
                          out_path = prepared_dir / f"clip_{idx}.mp4"

                          print(f"Downloading API clip {idx}: {url}")
                          ok = False
                          for attempt in range(3):
                              try:
                                  r = requests.get(url, stream=True, timeout=80)
                                  r.raise_for_status()
                                  with open(raw_path, "wb") as f:
                                      for chunk in r.iter_content(chunk_size=8192):
                                          f.write(chunk)
                                  ok = True
                                  break
                              except Exception as e:
                                  print(f"Download error (attempt {attempt+1}): {e}")
                                  time.sleep(2)

                          if not ok:
                              print("Skipping this API video after failed downloads.")
                              continue

                          cmd = (
                              f"ffmpeg -y -i \"{raw_path}\" "
                              f"-t 5 -an "
                              f"-vf scale=1080:1920:force_original_aspect_ratio=increase,"
                              f"crop=1080:1920 "
                              f"-c:v libx264 -preset veryfast -crf 25 "
                              f"\"{out_path}\""
                          )
                          print("Trimming & scaling (API):", cmd)
                          os.system(cmd)

                          try:
                              raw_path.unlink()
                          except Exception:
                              pass

                          if out_path.exists() and out_path.stat().st_size > 0:
                              downloaded.append(out_path)
                              print("Added API trimmed clip:", out_path)
                              if len(downloaded) >= n_clips:
                                  break

                  if not downloaded:
                      print("No Pexels clips downloaded, falling back to black video.")
                      downloaded = fallback_black(dur)

                  clips = downloaded

          print("Prepared clips:")
          for c in clips:
              print(" -", c)
          PY

      # ----------------------------------------------------------
      # BUILD CLIP LIST (ENSURE VIDEO COVERS AUDIO)
      # ----------------------------------------------------------
      - name: Build clip list
        run: |
          python << 'PY'
          import os, random, pathlib, math
          from pydub import AudioSegment

          audio = AudioSegment.from_wav("tts-audio.wav")
          dur = audio.duration_seconds
          print(f"Audio duration for clip planning: ~{dur:.1f}s")

          clips = sorted(str(p) for p in pathlib.Path("prepared").glob("*.mp4"))
          if not clips:
            raise SystemExit("No prepared clips found")

          random.shuffle(clips)
          needed = max(3, math.ceil(dur / 5.0))

          base = clips[:]
          if len(base) == 1:
            selected = base * needed
          else:
            selected = []
            while len(selected) < needed:
              random.shuffle(base)
              selected.extend(base)
            selected = selected[:needed]

          with open("clip_list.txt","w") as f:
            for c in selected:
              f.write(f"file '{os.path.abspath(c)}'\n")

          print("Using clips (looped as needed):")
          for c in selected:
            print(" -", c)
          PY

      # ----------------------------------------------------------
      # BUILD SUBTITLES (ASS, PROPORTIONAL TIMING)
      # ----------------------------------------------------------
      - name: Build Subtitles
        run: |
          python << 'PY'
          import re, textwrap
          from pydub import AudioSegment

          script = open("script.txt", encoding="utf-8").read()
          audio = AudioSegment.from_wav("tts-audio.wav")
          total = len(audio)

          sentences = re.split(r'(?<=[.!?])\s+', script)
          sentences = [s.strip() for s in sentences if s.strip()]

          if not sentences:
            raise SystemExit("No sentences for subtitles")

          chunks = []
          for s in sentences:
            lines = textwrap.wrap(s, 40)
            if len(lines) <= 2:
              chunks.append("\\N".join(lines))
            else:
              mid = len(lines)//2
              chunks.append("\\N".join([" ".join(lines[:mid]), " ".join(lines[mid:])]))

          lengths = [len(c) for c in chunks]
          total_len = sum(lengths)

          def fmt(ms):
            h = ms // 3600000
            ms %= 3600000
            m = ms // 60000
            ms %= 60000
            s = ms // 1000
            cs = (ms % 1000) // 10
            return f"{h}:{m:02d}:{s:02d}.{cs:02d}"

          out = []
          out.append("[Script Info]")
          out.append("ScriptType: v4.00+")
          out.append("PlayResX: 1080")
          out.append("PlayResY: 1920")
          out.append("")
          out.append("[V4+ Styles]")
          out.append("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding")
          out.append("Style: CrimeSub,Arial,42,&H00FFFFFF,&H00FFFFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,1,0,2,40,40,120,1")
          out.append("")
          out.append("[Events]")
          out.append("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text")

          cur = 0
          for i, (txt, L) in enumerate(zip(chunks, lengths), 1):
            share = L / total_len if total_len else 1/len(chunks)
            dur_i = int(total * share)
            if dur_i < 600:
              dur_i = 600
            start = fmt(cur)
            end_ms = cur + dur_i
            if i == len(chunks):
              end_ms = total - 100
            end = fmt(end_ms)
            cur = end_ms
            txt_esc = txt.replace("{", "\\{").replace("}", "\\}")
            out.append(f"Dialogue: 0,{start},{end},CrimeSub,,0,0,0,,{txt_esc}")

          with open("subtitles.ass","w",encoding="utf-8") as f:
            f.write("\n".join(out))

          print("subtitles.ass written")
          PY

      # ----------------------------------------------------------
      # RENDER FINAL VIDEO (VERTICAL, DARKENED, MAX 45s)
      # ----------------------------------------------------------
      - name: Render final video
        run: |
          set -euo pipefail
          if [ ! -s tts-audio.wav ]; then echo "no tts-audio.wav"; exit 1; fi
          if [ ! -s clip_list.txt ]; then echo "no clip_list.txt"; exit 1; fi
          if [ ! -s subtitles.ass ]; then echo "no subtitles.ass"; exit 1; fi

          ffmpeg -y \
            -f concat -safe 0 -i clip_list.txt \
            -i tts-audio.wav \
            -filter_complex "[0:v]setsar=1,eq=brightness=-0.12:contrast=1.25:saturation=0.9[v0];[v0]subtitles=subtitles.ass[v]" \
            -map "[v]" -map 1:a \
            -shortest \
            -t 45 \
            -r 30 \
            -c:v libx264 -preset veryfast -crf 21 \
            -c:a aac -b:a 192k \
            -movflags +faststart \
            -pix_fmt yuv420p \
            output.mp4

      # ----------------------------------------------------------
      # THUMBNAIL (USE REPO IMAGE, NO SCREENSHOT)
      # ----------------------------------------------------------
      - name: Thumbnail
        run: |
          python << 'PY'
          import os, shutil, subprocess

          dest = "thumbnail.jpg"

          preferred_names = ["thumbnail.jpg", "thumbnail.jpeg", "thumbnail.png"]
          found = None
          for name in preferred_names:
              if os.path.exists(name):
                  found = name
                  break

          if not found:
              candidates = []
              for f in os.listdir("."):
                  lower = f.lower()
                  if lower in ("thumbnail.jpg", "thumbnail.jpeg", "thumbnail.png"):
                      continue
                  if lower.endswith((".jpg",".jpeg",".png")) and not lower.startswith("output"):
                      candidates.append(f)

              if candidates:
                  candidates.sort()
                  found = candidates[0]

          if found:
              src_abs = os.path.abspath(found)
              dest_abs = os.path.abspath(dest)
              if src_abs != dest_abs:
                  shutil.copy(found, dest)
                  print("Using repo thumbnail:", found)
              else:
                  print("Repo already has thumbnail.jpg, using it as-is.")
          else:
              print("No thumbnail image found in repo. Creating dark placeholder thumbnail.")
              cmd = (
                  "ffmpeg -y -f lavfi -i color=c=black:s=1280x720:d=1 "
                  "-vframes 1 -q:v 2 thumbnail.jpg"
              )
              subprocess.run(cmd, shell=True, check=True)
          PY

      # ----------------------------------------------------------
      # SAVE USED TOPIC
      # ----------------------------------------------------------
      - name: Save used topic
        run: |
          set -euo pipefail
          TITLE="${TITLE:-Untitled Mystery}"
          echo "$TITLE" >> used_topics.txt
          tail -n 500 used_topics.txt > used_topics.tmp && mv used_topics.tmp used_topics.txt

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add used_topics.txt
          git commit -m "Add topic: $TITLE" || echo "No changes to commit"
          git push || echo "Git push failed – check logs"

      # ----------------------------------------------------------
      # UPLOAD ARTIFACTS
      # ----------------------------------------------------------
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: youtube-short-${{ env.CATEGORY }}-${{ github.run_id }}
          path: |
            output.mp4
            subtitles.ass
            script.txt
            groq_raw.json
            thumbnail.jpg
            used_topics.txt

      # ----------------------------------------------------------
      # JOB SUMMARY
      # ----------------------------------------------------------
      - name: Job summary
        if: always()
        run: |
          {
            echo "Title: $TITLE"
            echo "Category: $CATEGORY"
            echo "Description: $DESCRIPTION"
            echo "Visual keywords: $VISUAL_KEYWORDS"
          } | tee -a "$GITHUB_STEP_SUMMARY"
