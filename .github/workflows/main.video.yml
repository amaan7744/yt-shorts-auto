name: Auto YouTube Short

on:
  workflow_dispatch:
  schedule:
    # Run every 4 hours (6 times/day)
    - cron: "0 */4 * * *"

jobs:
  make-video:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install system deps and Python libs
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

          pip install --upgrade pip

          # IMPORTANT: downgrade NumPy so SciPy/TTS don't break on NumPy 2.x
          pip install --upgrade --force-reinstall "numpy<2"

          # Let pip resolve SciPy and other deps itself via TTS; keep transformers pinned
          pip install --upgrade TTS "transformers==4.29.2" requests

          # Optional: show versions (do NOT fail if scipy is missing)
          python - << 'EOF'
          try:
              import numpy
              print("NumPy version:", numpy.__version__)
          except Exception as e:
              print("Could not import numpy:", e)
          try:
              import scipy
              print("SciPy version:", scipy.__version__)
          except Exception as e:
              print("Could not import scipy (may be fine):", e)
          EOF

      - name: Pick category
        id: pick_category
        run: |
          CATEGORY=$(shuf -e horror crime mystery | head -n1)
          echo "CATEGORY=$CATEGORY" >> "$GITHUB_ENV"
          echo "Picked category: $CATEGORY"

      - name: Fetch Wikipedia source
        id: wiki
        run: |
          if [ "${CATEGORY}" = "horror" ]; then
            TOPIC="List_of_reportedly_haunted_locations_in_the_United_States"
          elif [ "${CATEGORY}" = "crime" ]; then
            TOPIC="List_of_unsolved_murder_cases_in_the_United_States"
          else
            TOPIC="List_of_missing_persons_cases"
          fi

          echo "Using Wikipedia topic: $TOPIC"

          TEXT=$(curl -s "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=1&titles=${TOPIC}&format=json" \
            | jq -r '.query.pages[]?.extract' | head -c 8000)

          if [ -z "$TEXT" ]; then
            echo "Error: Wikipedia returned empty text."
            exit 1
          fi

          {
            echo "source_text<<EOF"
            echo "$TEXT"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Generate metadata & script with Groq (retries + fallback)
        id: script
        env:
          GROQ_KEY: ${{ secrets.GROQ_KEY }}
        run: |
          if [ -z "${GROQ_KEY}" ]; then
            echo "Error: GROQ_KEY secret is not set."
            exit 1
          fi

          python << 'PY'
          import os, json, time, re, pathlib, sys
          import requests

          api_key = os.environ.get("GROQ_KEY")
          if not api_key:
              print("Error: GROQ_KEY not set", file=sys.stderr)
              sys.exit(1)

          category = os.environ.get("CATEGORY", "mystery")

          url = "https://api.groq.com/openai/v1/chat/completions"
          headers = {
              "Authorization": f"Bearer {api_key}",
              "Content-Type": "application/json",
          }

          payload = {
              "model": "llama-3.1-8b-instant",
              "temperature": 0.6,
              "max_tokens": 700,
              "messages": [
                  {
                      "role": "system",
                      "content": (
                          "You ONLY output valid JSON. Return a single JSON object with exactly these keys: "
                          "title (string), description (string), tags (array of strings), script (string). "
                          "No extra keys, no comments, no trailing commas. "
                          "The script must be suitable for a 30-40 second YouTube Short. "
                          "In the script, use \\n characters for line breaks instead of raw newlines."
                      ),
                  },
                  {
                      "role": "user",
                      "content": (
                          f"Write a 30-40 second YouTube Shorts script in American English about a {category} "
                          "true-crime or mystery story. The JSON MUST look like: "
                          "{\"title\": \"...\", \"description\": \"...\", \"tags\": [\"tag1\", \"tag2\"], \"script\": \"...\"}. "
                          "In the script, use \\n for line breaks, do NOT use S1/S2 labels, do NOT add extra double quotes "
                          "inside the script text. Output ONLY the JSON object."
                      ),
                  },
              ],
          }

          def try_parse(content: str):
              raw = content.strip()

              # Strip code fences if the model added them
              if raw.startswith("```"):
                  raw = re.sub(r"^```[a-zA-Z0-9]*\\s*", "", raw)
                  raw = re.sub(r"\\s*```$", "", raw)

              # Try direct json.loads
              try:
                  return json.loads(raw)
              except Exception:
                  pass

              # Fallback: slice from first { to last }
              start = raw.find("{")
              end = raw.rfind("}")
              if start == -1 or end == -1 or end <= start:
                  raise ValueError("No JSON object found in content")

              candidate = raw[start:end+1]

              # Remove trailing commas
              candidate = re.sub(r",(\\s*[}\\]])", r"\\1", candidate)

              # Escape raw newlines inside strings (safety)
              def fix_string(match):
                  s = match.group(0)
                  inner = s[1:-1]
                  inner = inner.replace("\\\\", "\\\\\\\\")
                  inner = inner.replace("\\r\\n", "\\\\n").replace("\\r", "\\\\n").replace("\\n", "\\\\n")
                  return '"' + inner + '"'

              candidate = re.sub(
                  r'"([^"\\\\]*(\\\\.[^"\\\\]*)*)"',
                  fix_string,
                  candidate,
                  flags=re.DOTALL,
              )

              return json.loads(candidate)

          MAX_ATTEMPTS = 3
          data = None

          for attempt in range(1, MAX_ATTEMPTS + 1):
              print(f"=== Groq attempt {attempt}/{MAX_ATTEMPTS} ===")
              try:
                  resp = requests.post(url, headers=headers, json=payload, timeout=60)
              except Exception as e:
                  print(f"Groq HTTP error on attempt {attempt}: {e}", file=sys.stderr)
                  time.sleep(3)
                  continue

              print("Groq s
