name: Auto YouTube Short

on:
  workflow_dispatch:
  schedule:
    # Run every 4 hours (6 times/day)
    - cron: "0 */4 * * *"

jobs:
  make-video:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install system deps and Python libs
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

          pip install --upgrade pip

          # CRITICAL: fix NumPy/SciPy versions so TTS + SciPy don't explode
          pip install --upgrade --force-reinstall "numpy<2" "scipy<1.12"

          # Install TTS and transformers with compatible NumPy/SciPy
          pip install --upgrade --force-reinstall TTS "transformers==4.29.2"

          # Optional: show final versions for debugging
          python - << 'EOF'
          import numpy, scipy
          print("NumPy version:", numpy.__version__)
          print("SciPy version:", scipy.__version__)
          EOF

      - name: Pick category
        id: pick_category
        run: |
          CATEGORY=$(shuf -e horror crime mystery | head -n1)
          echo "CATEGORY=$CATEGORY" >> "$GITHUB_ENV"
          echo "Picked category: $CATEGORY"

      - name: Fetch Wikipedia source
        id: wiki
        run: |
          if [ "${CATEGORY}" = "horror" ]; then
            TOPIC="List_of_reportedly_haunted_locations_in_the_United_States"
          elif [ "${CATEGORY}" = "crime" ]; then
            TOPIC="List_of_unsolved_murder_cases_in_the_United_States"
          else
            TOPIC="List_of_missing_persons_cases"
          fi

          echo "Using Wikipedia topic: $TOPIC"

          TEXT=$(curl -s "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=1&titles=${TOPIC}&format=json" \
            | jq -r '.query.pages[]?.extract' | head -c 8000)

          if [ -z "$TEXT" ]; then
            echo "Error: Wikipedia returned empty text."
            exit 1
          fi

          {
            echo "source_text<<EOF"
            echo "$TEXT"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Generate metadata & script with Groq (with JSON repair)
        id: script
        env:
          GROQ_KEY: ${{ secrets.GROQ_KEY }}
        run: |
          if [ -z "${GROQ_KEY}" ]; then
            echo "Error: GROQ_KEY secret is not set."
            exit 1
          fi

          cat << EOF > payload.json
          {
            "model": "llama-3.1-8b-instant",
            "temperature": 0.6,
            "max_tokens": 700,
            "messages": [
              {
                "role": "system",
                "content": "You ONLY output valid JSON. Return a single JSON object with exactly these keys: title (string), description (string), tags (array of strings), script (string). No extra keys, no comments, no trailing commas. In the script, use \\n characters for line breaks instead of raw newlines."
              },
              {
                "role": "user",
                "content": "Write a 25-35 second YouTube Shorts script in American English about a ${CATEGORY} true-crime or mystery story. The JSON MUST look like: {\"title\": \"...\", \"description\": \"...\", \"tags\": [\"tag1\", \"tag2\"], \"script\": \"...\"}. In the script, use \\n for line breaks, do NOT use S1/S2 labels, do NOT add extra double quotes inside the script text. Output ONLY the JSON object."
              }
            ]
          }
          EOF

          echo "Calling Groq..."
          JSON_OUT=$(curl -s https://api.groq.com/openai/v1/chat/completions \
            -H "Authorization: Bearer ${GROQ_KEY}" \
            -H "Content-Type: application/json" \
            -d @payload.json)

          echo "Raw Groq response:"
          echo "$JSON_OUT"

          # If Groq returns an error, fail early
          if echo "$JSON_OUT" | jq -e '.error' >/dev/null 2>&1; then
            echo "Groq API returned an error:"
            echo "$JSON_OUT"
            exit 1
          fi

          # Extract assistant content (model's JSON-shaped text)
          CONTENT_TEXT=$(echo "$JSON_OUT" | jq -r '.choices[0].message.content')

          if [ -z "$CONTENT_TEXT" ] || [ "$CONTENT_TEXT" = "null" ]; then
            echo "Error: Groq content text is empty."
            echo "$JSON_OUT"
            exit 1
          fi

          echo "Groq content text:"
          echo "$CONTENT_TEXT"

          # Save raw content for repair
          printf '%s\n' "$CONTENT_TEXT" > groq_raw_raw.txt

          # Repair JSON and save as groq_raw.json
          python << 'PY'
          import json, re, sys, pathlib

          raw_path = pathlib.Path("groq_raw_raw.txt")
          raw = raw_path.read_text(encoding="utf-8")

          # Try direct parse first
          try:
              data = json.loads(raw)
          except Exception:
              # Extract first JSON object
              m = re.search(r"\{.*\}", raw, re.DOTALL)
              if not m:
                  print("Error: could not find JSON object in Groq content", file=sys.stderr)
                  sys.exit(1)
              candidate = m.group(0)

              # Remove trailing commas before } or ]
              candidate = re.sub(r",(\s*[}\]])", r"\1", candidate)

              # Escape raw newlines inside string literals
              def fix_string(match):
                  s = match.group(0)  # full "..."
                  inner = s[1:-1]
                  inner = inner.replace("\\", "\\\\")
                  inner = inner.replace("\r\n", "\\n").replace("\r", "\\n").replace("\n", "\\n")
                  return '"' + inner + '"'

              candidate = re.sub(
                  r'"([^"\\]*(\\.[^"\\]*)*)"',
                  fix_string,
                  candidate,
                  flags=re.DOTALL,
              )

              data = json.loads(candidate)

          required = ["title", "description", "script"]
          for k in required:
              v = data.get(k, "")
              if not isinstance(v, str) or not v.strip():
                  print(f"Error: field '{k}' missing or empty in Groq JSON", file=sys.stderr)
                  sys.exit(1)

          if "tags" not in data or not isinstance(data["tags"], list):
              data["tags"] = []

          out_path = pathlib.Path("groq_raw.json")
          out_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
          PY

          echo "Cleaned Groq JSON:"
          cat groq_raw.json

          TITLE=$(jq -r '.title' groq_raw.json)
          DESCRIPTION=$(jq -r '.description' groq_raw.json)
          TAGS=$(jq -r '.tags | join(",")' groq_raw.json)
          SCRIPT=$(jq -r '.script' groq_raw.json)

          if [ -z "$SCRIPT" ] || [ "$SCRIPT" = "null" ]; then
            echo "Error: script from Groq is empty after cleaning."
            exit 1
          fi

          # Write script directly to file (no broken env multiline handling)
          printf '%s\n' "$SCRIPT" > script.txt

          if [ ! -s script.txt ]; then
            echo "Error: script.txt is empty after writing SCRIPT."
            exit 1
          fi

          echo "Generated title: $TITLE"

          {
            echo "TITLE=$TITLE"
            echo "DESCRIPTION=$DESCRIPTION"
            echo "TAGS=$TAGS"
          } >> "$GITHUB_ENV"

      - name: Build Subtitles
        run: |
          python << 'EOF'
          import os

          if not os.path.exists("script.txt"):
              print("Error: script.txt not found.")
              raise SystemExit(1)

          with open("script.txt", "r", encoding="utf-8") as f:
              script = f.read()

          if not script.strip():
              print("Error: script.txt is empty.")
              raise SystemExit(1)

          lines = [l.strip() for l in script.split("\n") if l.strip()]

          def tc(ms):
              h = ms//3600000; ms%=3600000
              m = ms//60000; ms%=60000
              s = ms//1000; r = ms%1000
              return f"{h:02}:{m:02}:{s:02},{r:03}"

          time = 0
          srt_lines = []
          index = 1

          for line in lines:
              start = time
              end = time + 3000  # 3 seconds per line
              srt_lines.append(str(index))
              srt_lines.append(f"{tc(start)} --> {tc(end)}")
              srt_lines.append(line)
              srt_lines.append("")
              index += 1
              time = end

          with open("subtitles.srt", "w", encoding="utf-8") as f:
              f.write("\n".join(srt_lines))

          print("subtitles.srt written.")
          EOF

      - name: Fetch Pexels Video
        env:
          PEXELS_KEY: ${{ secrets.PEXELS_KEY }}
        run: |
          if [ -z "${PEXELS_KEY}" ]; then
            echo "Error: PEXELS_KEY secret is not set."
            exit 1
          fi

          RESP=$(curl -s -H "Authorization: ${PEXELS_KEY}" \
            "https://api.pexels.com/videos/search?query=${CATEGORY}&per_page=1")
          echo "Raw Pexels response:"
          echo "$RESP"

          VIDEO_URL=$(echo "$RESP" | jq -r '.videos[0].video_files[0].link')

          if [ -z "$VIDEO_URL" ] || [ "$VIDEO_URL" = "null" ]; then
            echo "Error: Pexels returned no video URL."
            exit 1
          fi

          echo "Video URL: $VIDEO_URL"
          curl -L "$VIDEO_URL" -o video.mp4

          if [ ! -s video.mp4 ]; then
            echo "Error: downloaded video.mp4 is empty."
            exit 1
          fi

      - name: Generate Voice (XTTS)
        env:
          COQUI_TOS_AGREED: "1"
        run: |
          python << 'EOF'
          import os, sys
          from TTS.api import TTS

          if not os.path.exists("script.txt"):
              print("Error: script.txt not found for TTS.")
              sys.exit(1)

          if not os.path.exists("voices/aman.wav"):
              print("Error: voices/aman.wav not found. Please add your voice sample.")
              sys.exit(1)

          with open("script.txt", "r", encoding="utf-8") as f:
              script = f.read()

          if not script.strip():
              print("Error: script.txt is empty for TTS.")
              sys.exit(1)

          print("Loading TTS model (xtts_v2)...")
          tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2")
          print("Synthesizing speech...")
          tts.tts_to_file(
              text=script,
              file_path="tts-audio.wav",
              speaker_wav="voices/aman.wav",
              language="en"
          )

          if not os.path.exists("tts-audio.wav"):
              print("Error: tts-audio.wav was not created.")
              sys.exit(1)

          print("TTS audio saved to tts-audio.wav")
          EOF

      - name: Render Final Video
        run: |
          if [ ! -s video.mp4 ]; then
            echo "Error: video.mp4 missing or empty before ffmpeg."
            exit 1
          fi
          if [ ! -s tts-audio.wav ]; then
            echo "Error: tts-audio.wav missing or empty before ffmpeg."
            exit 1
          fi
          if [ ! -s subtitles.srt ]; then
            echo "Error: subtitles.srt missing or empty before ffmpeg."
            exit 1
          fi

          ffmpeg -y \
            -i video.mp4 \
            -i tts-audio.wav \
            -vf "scale=1080:-2,crop=1080:1920,subtitles=subtitles.srt" \
            -map 0:v -map 1:a \
            -shortest \
            -c:v libx264 -preset veryfast -crf 23 \
            -c:a aac \
            output.mp4

          if [ ! -s output.mp4 ]; then
            echo "Error: ffmpeg did not produce output.mp4."
            exit 1
          fi

      - name: Generate Thumbnail
        run: |
          if [ ! -s output.mp4 ]; then
            echo "Error: output.mp4 missing before thumbnail step."
            exit 1
          fi

          ffmpeg -y \
            -ss 00:00:02 -i output.mp4 -vframes 1 \
            -vf "scale=1280:-2,drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:text='${TITLE}':fontcolor=white:fontsize=48:box=1:boxcolor=black@0.6:boxborderw=20:x=(w-text_w)/2:y=h*0.15" \
            thumbnail.jpg

          if [ ! -s thumbnail.jpg ]; then
            echo "Error: thumbnail.jpg was not created."
            exit 1
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: youtube-short
          path: |
            output.mp4
            thumbnail.jpg
            subtitles.srt
            groq_raw.json
            groq_raw_raw.txt
            script.txt
