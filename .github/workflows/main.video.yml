name: Auto YouTube Short

on:
  workflow_dispatch:
  schedule:
    # Run every 4 hours (6 times/day)
    - cron: "0 */4 * * *"

jobs:
  make-video:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python 3.10
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install system deps and Python libs
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq

          pip install --upgrade pip

          # IMPORTANT: downgrade NumPy so SciPy/TTS don't break on NumPy 2.x
          pip install --upgrade --force-reinstall "numpy<2"

          # Let pip resolve SciPy and other deps itself via TTS; keep transformers pinned
          pip install --upgrade TTS "transformers==4.29.2" requests

          # Optional: show versions (do NOT fail if scipy is missing)
          python - << 'EOF'
          try:
              import numpy
              print("NumPy version:", numpy.__version__)
          except Exception as e:
              print("Could not import numpy:", e)
          try:
              import scipy
              print("SciPy version:", scipy.__version__)
          except Exception as e:
              print("Could not import scipy (may be fine):", e)
          EOF

      - name: Pick category
        id: pick_category
        run: |
          CATEGORY=$(shuf -e horror crime mystery | head -n1)
          echo "CATEGORY=$CATEGORY" >> "$GITHUB_ENV"
          echo "Picked category: $CATEGORY"

      - name: Fetch Wikipedia source
        id: wiki
        run: |
          if [ "${CATEGORY}" = "horror" ]; then
            TOPIC="List_of_reportedly_haunted_locations_in_the_United_States"
          elif [ "${CATEGORY}" = "crime" ]; then
            TOPIC="List_of_unsolved_murder_cases_in_the_United_States"
          else
            TOPIC="List_of_missing_persons_cases"
          fi

          echo "Using Wikipedia topic: $TOPIC"

          TEXT=$(curl -s "https://en.wikipedia.org/w/api.php?action=query&prop=extracts&explaintext=1&titles=${TOPIC}&format=json" \
            | jq -r '.query.pages[]?.extract' | head -c 8000)

          if [ -z "$TEXT" ]; then
            echo "Error: Wikipedia returned empty text."
            exit 1
          fi

          {
            echo "source_text<<EOF"
            echo "$TEXT"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Generate metadata & script with Groq (retries + fallback)
        id: script
        env:
          GROQ_KEY: ${{ secrets.GROQ_KEY }}
        run: |
          if [ -z "${GROQ_KEY}" ]; then
            echo "Error: GROQ_KEY secret is not set."
            exit 1
          fi

          python << 'PY'
          import os, json, time, re, pathlib, sys
          import requests

          api_key = os.environ.get("GROQ_KEY")
          if not api_key:
              print("Error: GROQ_KEY not set", file=sys.stderr)
              sys.exit(1)

          category = os.environ.get("CATEGORY", "mystery")

          url = "https://api.groq.com/openai/v1/chat/completions"
          headers = {
              "Authorization": f"Bearer {api_key}",
              "Content-Type": "application/json",
          }

          payload = {
              "model": "llama-3.1-8b-instant",
              "temperature": 0.6,
              "max_tokens": 700,
              "messages": [
                  {
                      "role": "system",
                      "content": (
                          "You ONLY output valid JSON. Return a single JSON object with exactly these keys: "
                          "title (string), description (string), tags (array of strings), script (string). "
                          "No extra keys, no comments, no trailing commas. "
                          "In the script, use \\n characters for line breaks instead of raw newlines."
                      ),
                  },
                  {
                      "role": "user",
                      "content": (
                          f"Write a 25-35 second YouTube Shorts script in American English about a {category} "
                          "true-crime or mystery story. The JSON MUST look like: "
                          "{\"title\": \"...\", \"description\": \"...\", \"tags\": [\"tag1\", \"tag2\"], \"script\": \"...\"}. "
                          "In the script, use \\n for line breaks, do NOT use S1/S2 labels, do NOT add extra double quotes "
                          "inside the script text. Output ONLY the JSON object."
                      ),
                  },
              ],
          }

          def try_parse(content: str):
              raw = content.strip()

              # Strip code fences if the model added them
              if raw.startswith("```"):
                  raw = re.sub(r"^```[a-zA-Z0-9]*\s*", "", raw)
                  raw = re.sub(r"\s*```$", "", raw)

              # Try direct json.loads
              try:
                  return json.loads(raw)
              except Exception:
                  pass

              # Fallback: slice from first { to last }
              start = raw.find("{")
              end = raw.rfind("}")
              if start == -1 or end == -1 or end <= start:
                  raise ValueError("No JSON object found in content")

              candidate = raw[start:end+1]

              # Remove trailing commas
              candidate = re.sub(r",(\s*[}\]])", r"\1", candidate)

              # Escape raw newlines inside strings (safety)
              def fix_string(match):
                  s = match.group(0)
                  inner = s[1:-1]
                  inner = inner.replace("\\", "\\\\")
                  inner = inner.replace("\r\n", "\\n").replace("\r", "\\n").replace("\n", "\\n")
                  return '"' + inner + '"'

              candidate = re.sub(
                  r'"([^"\\]*(\\.[^"\\]*)*)"',
                  fix_string,
                  candidate,
                  flags=re.DOTALL,
              )

              return json.loads(candidate)

          MAX_ATTEMPTS = 3
          data = None

          for attempt in range(1, MAX_ATTEMPTS + 1):
              print(f"=== Groq attempt {attempt}/{MAX_ATTEMPTS} ===")
              try:
                  resp = requests.post(url, headers=headers, json=payload, timeout=60)
              except Exception as e:
                  print(f"Groq HTTP error on attempt {attempt}: {e}", file=sys.stderr)
                  time.sleep(3)
                  continue

              print("Groq status code:", resp.status_code)
              try:
                  api_json = resp.json()
              except Exception as e:
                  print("Failed to parse Groq API JSON:", e, file=sys.stderr)
                  time.sleep(3)
                  continue

              # Save for debugging
              pathlib.Path("groq_api_response.json").write_text(
                  json.dumps(api_json, ensure_ascii=False, indent=2),
                  encoding="utf-8",
              )

              if "error" in api_json:
                  print("Groq API error:", api_json["error"], file=sys.stderr)
                  time.sleep(3)
                  continue

              content = (
                  api_json.get("choices", [{}])[0]
                  .get("message", {})
                  .get("content", "")
              )
              if not content or not isinstance(content, str):
                  print("Groq content empty or invalid", file=sys.stderr)
                  time.sleep(3)
                  continue

              print("Groq content:")
              print(content)

              try:
                  data = try_parse(content)
              except Exception as e:
                  print("Groq JSON parse error:", e, file=sys.stderr)
                  time.sleep(3)
                  continue

              # Validate minimal fields
              ok = True
              for key in ["title", "description", "script"]:
                  v = data.get(key)
                  if not isinstance(v, str) or not v.strip():
                      print(f"Groq JSON missing/empty field: {key}", file=sys.stderr)
                      ok = False
                      break
              if not ok:
                  time.sleep(3)
                  continue

              if "tags" not in data or not isinstance(data["tags"], list):
                  data["tags"] = []

              print("Groq JSON parsed successfully.")
              break

          if data is None:
              print("Groq failed after all attempts, using fallback script.", file=sys.stderr)
              data = {
                  "title": "A Chilling Mystery That Was Never Solved",
                  "description": "A short true-crime style mystery about a person who vanished without a trace, still unsolved to this day.",
                  "tags": ["true crime", "mystery", "unsolved"],
                  "script": (
                      "Imagine someone you know walks out of their home one evening and is never seen again.\\n"
                      "No note, no clear motive, and no trace left behind.\\n"
                      "Friends and family search everywhere, but every lead ends in a dead end.\\n"
                      "The police investigate for years, yet no suspect is ever charged.\\n"
                      "To this day, the case remains unsolved, leaving only rumors, theories, and a chilling question:\\n"
                      "how can a person simply vanish into thin air?"
                  ),
              }

          # Save cleaned JSON and script
          pathlib.Path("groq_raw.json").write_text(
              json.dumps(data, ensure_ascii=False, indent=2),
              encoding="utf-8",
          )
          pathlib.Path("script.txt").write_text(data["script"], encoding="utf-8")

          title = data.get("title") or "Untitled Mystery Short"
          description = data.get("description") or ""
          tags = data.get("tags") or []

          # Sanitize title for ffmpeg drawtext (no quotes/special chars)
          safe_title = re.sub(r"[^A-Za-z0-9 _-]", "", title)
          safe_title = safe_title[:60] or "Mystery Short"

          env_path = os.environ.get("GITHUB_ENV")
          if env_path:
              with open(env_path, "a", encoding="utf-8") as f:
                  f.write(f"TITLE={title}\n")
                  f.write(f"DESCRIPTION={description}\n")
                  f.write(f"TAGS={','.join(tags)}\n")
                  f.write(f"SANITIZED_TITLE={safe_title}\n")

          print("Groq processing complete. Title:", title)
          print("Sanitized title for thumbnail:", safe_title)
          PY

      - name: Build Subtitles
        run: |
          python << 'EOF'
          import os

          if not os.path.exists("script.txt"):
              print("Error: script.txt not found.")
              raise SystemExit(1)

          with open("script.txt", "r", encoding="utf-8") as f:
              script = f.read()

          if not script.strip():
              print("Error: script.txt is empty.")
              raise SystemExit(1)

          lines = [l.strip() for l in script.split("\n") if l.strip()]

          def tc(ms):
              h = ms//3600000; ms%=3600000
              m = ms//60000; ms%=60000
              s = ms//1000; r = ms%1000
              return f"{h:02}:{m:02}:{s:02},{r:03}"

          time = 0
          srt_lines = []
          index = 1

          for line in lines:
              start = time
              end = time + 3000  # 3 seconds per line
              srt_lines.append(str(index))
              srt_lines.append(f"{tc(start)} --> {tc(end)}")
              srt_lines.append(line)
              srt_lines.append("")
              index += 1
              time = end

          with open("subtitles.srt", "w", encoding="utf-8") as f:
              f.write("\n".join(srt_lines))

          print("subtitles.srt written.")
          EOF

      - name: Fetch Pexels Video (3 attempts + fallback background)
        env:
          PEXELS_KEY: ${{ secrets.PEXELS_KEY }}
        run: |
          if [ -z "${PEXELS_KEY}" ]; then
            echo "Error: PEXELS_KEY secret is not set."
            exit 1
          fi

          MAX_ATTEMPTS=3
          SUCCESS=0
          QUERY="${CATEGORY}"

          for ATTEMPT in $(seq 1 $MAX_ATTEMPTS); do
            echo "=== Pexels attempt $ATTEMPT/$MAX_ATTEMPTS with query '${QUERY}' ==="

            RESP=$(curl -s -H "Authorization: ${PEXELS_KEY}" \
              "https://api.pexels.com/videos/search?query=${QUERY}&per_page=1")
            echo "Raw Pexels response:"
            echo "$RESP"

            VIDEO_URL=$(echo "$RESP" | jq -r '.videos[0].video_files[0].link // empty')

            if [ -n "$VIDEO_URL" ]; then
              echo "Video URL: $VIDEO_URL"
              curl -L "$VIDEO_URL" -o video.mp4
              if [ -s video.mp4 ]; then
                echo "Downloaded video.mp4 successfully."
                SUCCESS=1
                break
              fi
            fi

            echo "No video found or download failed for '${QUERY}', retrying with fallback keyword..."
            if [ "${CATEGORY}" = "horror" ]; then
              QUERY="dark"
            elif [ "${CATEGORY}" = "crime" ]; then
              QUERY="city night"
            else
              QUERY="mystery fog"
            fi
            sleep 3
          done

          if [ $SUCCESS -ne 1 ]; then
            echo "Pexels failed after $MAX_ATTEMPTS attempts, generating fallback background video."
            # 35-second black background, 1080x1920, 30 fps
            ffmpeg -y -f lavfi -i color=c=black:s=1080x1920:d=35 -r 30 video.mp4
          fi

          if [ ! -s video.mp4 ]; then
            echo "Error: video.mp4 missing even after fallback."
            exit 1
          fi

      - name: Generate Voice (XTTS)
        env:
          COQUI_TOS_AGREED: "1"
        run: |
          python << 'EOF'
          import os, sys
          from TTS.api import TTS

          if not os.path.exists("script.txt"):
              print("Error: script.txt not found for TTS.")
              sys.exit(1)

          if not os.path.exists("voices/aman.wav"):
              print("Error: voices/aman.wav not found. Please add your voice sample.")
              sys.exit(1)

          with open("script.txt", "r", encoding="utf-8") as f:
              script = f.read()

          if not script.strip():
              print("Error: script.txt is empty for TTS.")
              sys.exit(1)

          print("Loading TTS model (tts_models/multilingual/multi-dataset/xtts_v2)...")
          tts = TTS("tts_models/multilingual/multi-dataset/xtts_v2")

          print("Synthesizing speech...")
          tts.tts_to_file(
              text=script,
              file_path="tts-audio.wav",
              speaker_wav="voices/aman.wav",
              language="en"
          )

          if not os.path.exists("tts-audio.wav"):
              print("Error: tts-audio.wav was not created.")
              sys.exit(1)

          print("TTS audio saved to tts-audio.wav")
          EOF

      - name: Render Final Video
        run: |
          if [ ! -s video.mp4 ]; then
            echo "Error: video.mp4 missing or empty before ffmpeg."
            exit 1
          fi
          if [ ! -s tts-audio.wav ]; then
            echo "Error: tts-audio.wav missing or empty before ffmpeg."
            exit 1
          fi
          if [ ! -s subtitles.srt ]; then
            echo "Error: subtitles.srt missing or empty before ffmpeg."
            exit 1
          fi

          ffmpeg -y \
            -i video.mp4 \
            -i tts-audio.wav \
            -vf "scale=1080:-2,crop=1080:1920,subtitles=subtitles.srt" \
            -map 0:v -map 1:a \
            -shortest \
            -c:v libx264 -preset veryfast -crf 23 \
            -c:a aac \
            output.mp4

          if [ ! -s output.mp4 ]; then
            echo "Error: ffmpeg did not produce output.mp4."
            exit 1
          fi

      - name: Generate Thumbnail
        run: |
          if [ ! -s output.mp4 ]; then
            echo "Error: output.mp4 missing before thumbnail step."
            exit 1
          fi

          # Use sanitized title to avoid ffmpeg exploding on quotes/special chars
          TEXT_TITLE="${SANITIZED_TITLE:-Mystery Short}"

          ffmpeg -y \
            -ss 00:00:02 -i output.mp4 -vframes 1 \
            -vf "scale=1280:-2,drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:text='${TEXT_TITLE}':fontcolor=white:fontsize=48:box=1:boxcolor=black@0.6:boxborderw=20:x=(w-text_w)/2:y=h*0.15" \
            thumbnail.jpg

          if [ ! -s thumbnail.jpg ]; then
            echo "Error: thumbnail.jpg was not created."
            exit 1
          fi

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: youtube-short
          path: |
            output.mp4
            thumbnail.jpg
            subtitles.srt
            groq_raw.json
            script.txt
            groq_api_response.json
